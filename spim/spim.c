//------------------------------------------------------------------------------
// This is Open source software. You can place this code on your site, but don't
// forget a link to my YouTube-channel: https://www.youtube.com/channel/UChButpZaL5kUUl_zTyIDFkQ
// Это программное обеспечение распространяется свободно. Вы можете размещать
// его на вашем сайте, но не забудьте указать ссылку на мой YouTube-канал
// "Электроника в объектике" https://www.youtube.com/channel/UChButpZaL5kUUl_zTyIDFkQ
// Автор: Надыршин Руслан / Nadyrshin Ruslan
//------------------------------------------------------------------------------
#include <avr/io.h>

#include "spim.h"


spi_endhandler spi_endfunc;

static uint8_t *pSPI_TxBuff;
static uint8_t *pSPI_RxBuff;
uint16_t spim_Len;
uint8_t spim_IsBisy = 0;

//==============================================================================
// Процедура инициализации spi в режиме master
//==============================================================================
void spim_init(void)
{
	// Настраиваем ножки сигналов SCK и MOSI. Их расположение перенастроить у AVR нельзя
	
	DDRB |=  ((1 << 1) | (1 << 2) | (1 << 0));
	
	// MISO
	DDRB &= ~(1 << 3);
	PORTB |= (1 << 3);
	
	// Для ST7920 частота SPI не более 2.5 МГц, CPOL=1, CPHA=1
	SPCR |= (1 << SPE) | (1 << MSTR);// | (1 << CPOL) | (1 << CPHA);
	//SPSR |= (1 << SPR0);
	//SPSR |= (1 << SPI2X);

}
//==============================================================================


//==============================================================================
// Процедура отправляет массив 8-битных слов
//==============================================================================
void SPI_send8b(uint8_t *pBuff, uint16_t Len)
{
	SPI_SendRecv(pBuff, 0, Len);
}
//==============================================================================


//==============================================================================
// Процедура отправляет массив 8-битных слов с использованием прерываний SPI
//==============================================================================
void SPI_send8b_irq(uint8_t *pBuff, uint16_t Len, void (*func)(void))
{
	SPI_SendRecv_irq(pBuff, 0, Len, func);
}
//==============================================================================


//==============================================================================
// Процедура отправляет массив 8-битных слов
//==============================================================================
void SPI_recv8b(uint8_t *pBuff, uint16_t Len)
{
	SPI_SendRecv(0, pBuff, Len);
}
//==============================================================================


//==============================================================================
// Процедура принимает массив 8-битных слов с использованием прерываний SPI
//==============================================================================
void SPI_recv8b_irq(uint8_t *pBuff, uint16_t Len, void (*func)(void))
{
	SPI_SendRecv_irq(0, pBuff, Len, func);
}
//==============================================================================


//==============================================================================
// Процедура отправляет 1 байт и возвращает принятый байт
//==============================================================================
uint8_t SPI_SendRecvByte(uint8_t TxByte)
{
	spim_IsBisy = 1;

	SPDR = TxByte;
	while(!(SPSR & (1<<SPIF)));
	
	spim_IsBisy = 0;
	
	return SPDR;
}
//==============================================================================


//==============================================================================
// Процедура отправляет/принимает массив 8-битных слов
//==============================================================================
void SPI_SendRecv(uint8_t *pTxBuff, uint8_t *pRxBuff, uint16_t Len)
{
	if (((!pTxBuff) && (!pRxBuff)) || (!Len))
	return;
	
	volatile uint8_t tmp;
	spim_IsBisy = 1;

	for (uint16_t i = 0; i < Len; i++)
	{
		SPDR = (pTxBuff) ? *(pTxBuff++) : 0xFF;
		while(!(SPSR & (1<<SPIF)));

		if (pRxBuff)
		*(pRxBuff++) = SPDR;
		else
		tmp = SPDR;
	}
	
	spim_IsBisy = 0;
}
//==============================================================================


//==============================================================================
// Процедура отправляет/принимает массив 8-битных слов с использованием прерываний
//==============================================================================
void SPI_SendRecv_irq(uint8_t *pTxBuff, uint8_t *pRxBuff, uint16_t Len, void (*func)(void))
{
	if (((!pTxBuff) && (!pRxBuff)) || (!Len))
	return;
	
	// Запоминаем указатель на функцию, которую нужно будет вызвать по окончанию приёмо-передачи по SPI
	spi_endfunc = func;

	spim_IsBisy = 1;
	
	pSPI_TxBuff = pTxBuff;
	pSPI_RxBuff = pRxBuff;
	spim_Len = Len;
	
	// Включаем прерывания от SPI
	SPCR |= (1 << SPIE);
	// Сбрасываем флаги прерываний
	volatile uint8_t tmp = SPSR;

	// Выдаём первый байт, остальные будем выдавать в обработчике прерывания
	SPDR = (pSPI_TxBuff) ? *(pSPI_TxBuff++) : 0xFF;
}
//==============================================================================


//==============================================================================
// Обработчик прерывания SPI
//==============================================================================
ISR(SPI_STC_vect)

{
	volatile uint8_t tmp;

	if (pSPI_RxBuff)
	*(pSPI_RxBuff++) = SPDR;
	else
	tmp = SPDR;
	
	if (--spim_Len) // Есть ещё данные на передачу
	SPDR = (pSPI_TxBuff) ? *(pSPI_TxBuff++) : 0xFF;
	else          // Все данные переданы
	{
		spim_IsBisy = 0;

		// Отключаем прерывания от SPI
		SPCR &= ~(1 << SPIE);

		if (spi_endfunc)    // Функция окончания передачи была назначена при инициализации SPI
		spi_endfunc();    // Вызываем функцию
	}
}
//==============================================================================


//==============================================================================
// Процедура отправляет массив 16-битных слов
//==============================================================================
void SPI_send16b(uint16_t *pBuff, uint16_t Len)
{
	spim_IsBisy = 1;
	
	for (uint16_t i = 0; i < Len; i++)
	{
		// Выдаём старший байт
		SPDR = (*pBuff) >> 8;
	while (!(SPSR & (1 << SPIF)))  {}
	// Выдаём младший байт
	SPDR = (*pBuff) & 0xFF;
while (!(SPSR & (1 << SPIF)))  {}

pBuff++;
  }
  
  spim_IsBisy = 0;
}
//==============================================================================


//==============================================================================
// Процедура отправляет массив 16-битных слов
//==============================================================================
void SPI_recv16b(uint16_t *pBuff, uint16_t Len)
{
  uint16_t tmp;

  spim_IsBisy = 1;
  
  for (uint16_t i = 0; i < Len; i++)
  {
   SPDR = 0xFF;
   while(!(SPSR & (1<<SPIF)));
   tmp = (SPDR << 8);
   SPDR = 0xFF;
   while(!(SPSR & (1<<SPIF)));
   tmp |= SPDR;
   
   *(pBuff++) = tmp;
  }
  
  spim_IsBisy = 0;
}
//==============================================================================
