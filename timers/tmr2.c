//------------------------------------------------------------------------------
// This is Open source software. You can place this code on your site, but don't
// forget a link to my YouTube-channel: https://www.youtube.com/channel/UChButpZaL5kUUl_zTyIDFkQ
// Это программное обеспечение распространяется свободно. Вы можете размещать
// его на вашем сайте, но не забудьте указать ссылку на мой YouTube-канал
// "Электроника в объектике" https://www.youtube.com/channel/UChButpZaL5kUUl_zTyIDFkQ
// Автор: Надыршин Руслан / Nadyrshin Ruslan
//------------------------------------------------------------------------------
#include <avr/io.h>
#define F_CPU 1000000UL
#include <avr/interrupt.h>
#include "timers.h"
#include "tmr2.h"

tmr_handler tmr2_handler;
uint8_t CSreg2 = (1 << CS20);


// Возможные делители таймера2
const uint16_t tmr2_divs[] =
{
	1,
	8,
	32,
	64,
	128,
	256,
	1024
};


//==============================================================================
//
//==============================================================================
uint8_t timer2_getCSregbits(uint16_t Divider)
{
	switch (Divider)
	{
		case 1:
		return (1 << CS20);
		case 8:
		return (1 << CS21);
		case 32:
		return (1 << CS20) | (1 << CS21);
		case 64:
		return (1 << CS22);
		case 128:
		return (1 << CS20) | (1 << CS22);
		case 256:
		return (1 << CS21) | (1 << CS22);
		case 1024:
		return (1 << CS20) | (1 << CS21) | (1 << CS22);
		default:
		return 0x00;
	}
}
//==============================================================================


//==============================================================================
// Процедура настраивает таймер
//==============================================================================
void tmr2_init(uint32_t Freq, void (*func)(void))
{
	// Запрещаем прерывания глобально
	cli();
	
	// Запоминаем функцию, которую нужно вызывать в обработчике прерывания таймера
	tmr2_handler = func;
	
	// Настраиваем режим работы таймера
	// Режим CTC, выходы на OC2A, OC2B не используем
	// Прерывание по сравнению TCNT2 и OCR2A
	
	TCCR2 = 0x00;
	TCCR2 = 0x00;
	TCCR2 |= (1 << WGM21);
	TCCR2 |= (1 << FOC2);
	
	// Считаем необходимый делитель таймера и значение для сравнения
	uint32_t Coef = F_CPU * 1000000 / Freq;
	uint32_t OC2_value = 256;
	
	// Перебираем делители таймера начиная с наименьшего
	for (uint8_t i = 0; i < (sizeof(tmr2_divs) / sizeof(tmr2_divs[0])); i++)
	{
		OC2_value = Coef / tmr2_divs[i];
		
		if (OC2_value < 256)        // Делитель выбран
		{
			CSreg2 = timer2_getCSregbits(tmr2_divs[i]);
			break;
		}
	}
	
	// Значение для сравнения
	OCR2 = (uint8_t) (OC2_value - 1);
	// Сбрасываем флаги прерываний таймера
	TIFR = (1 << TOV2) | (1 << OCF2) | (1 << OCF2);
	// Включаем прерывание по сравнению TCNT2 и OCR2A
	TIMSK = (1 << OCIE2);
	
	// Разрешаем прерывания глобально
	sei();
}
//==============================================================================


//==============================================================================
// Процедура стартует таймер
//==============================================================================
void tmr2_start(void)
{
	TCNT2 = 0;
	TCCR2 = CSreg2;
}
//==============================================================================


//==============================================================================
// Процедура останавливает таймер
//==============================================================================
void tmr2_stop(void)
{
	TCCR2 = 0x00;
}
//==============================================================================


//==============================================================================
// Обработчик прерывания таймера2
//==============================================================================
ISR(TIMER2_COMP_vect)
{
	tmr2_handler();
}
//==============================================================================
